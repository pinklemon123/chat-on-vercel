<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Chat</title>
<link rel="stylesheet" href="/styles.css" />
<div class="page">
  <div class="glass">
    <header>
      <h1>AI Chat</h1>
    </header>

    <main id="chat"></main>

    <form id="composer">
      <textarea id="q" rows="3" placeholder="和我聊点什么…（Enter 发送，Shift+Enter 换行）"></textarea>
      <button id="send" type="submit">发送</button>
    </form>
  </div>
</div>

<script>
const chat = document.getElementById('chat');
const form = document.getElementById('composer');
const input = document.getElementById('q');
const sendBtn = document.getElementById('send');

function addBubble(role, text='') {
  const wrap = document.createElement('div');
  wrap.className = `bubble ${role}`;
  const avatar = document.createElement('div');
  avatar.className = 'avatar';
  avatar.textContent = role === 'user' ? '你' : 'AI';
  const body = document.createElement('div');
  body.className = 'body';
  body.textContent = text;
  wrap.appendChild(avatar);
  wrap.appendChild(body);
  chat.appendChild(wrap);
  chat.scrollTop = chat.scrollHeight;
  return body; // 返回文本节点容器，便于流式追加
}

function setBusy(busy) {
  input.disabled = busy;
  sendBtn.disabled = busy;
  sendBtn.textContent = busy ? '发送中…' : '发送';
}

// Enter 发送，Shift+Enter 换行
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    form.requestSubmit();
  }
});

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text) return;

  // 用户消息
  addBubble('user', text);

  // 清空输入并禁用控件
  input.value = '';
  setBusy(true);

  // 预先添加 AI 气泡，后续流式填充
  const out = addBubble('assistant', '');

  try {
    const resp = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ messages: [{ role:'user', content: text }] })
    });
    if (!resp.ok || !resp.body) {
      out.textContent = `（出错：${resp.status}）`;
      setBusy(false);
      return;
    }

    // 后端已清洗为纯文本流：直接按字节显示
    const reader = resp.body.getReader();
    const dec = new TextDecoder();
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      out.textContent += dec.decode(value);
      chat.scrollTop = chat.scrollHeight;
    }
  } catch (err) {
    out.textContent = '（网络异常或服务不可用）';
    console.error(err);
  } finally {
    setBusy(false);
  }
});
</script>
